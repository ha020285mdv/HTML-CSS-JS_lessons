# Lesson 3
# Формы, picture и JS

<h2 id="forms">Формы</h2>

__Формы__ - это инструмент HTML для взаимодействия пользователя с сайтом.

С помощью форм пользователь может вводить какие-либо данные - написать комментарий, выбрать товар и оплатить его с помощью кредитной карты, подобрать подходящий маршрут на карте и т.п.

Все это возможно благодаря тому, что браузер умеет с помощью форм получить данные пользователя и затем обрабатывает эти данные сам либо пересылает данные на обработку серверу.

Когда говорят о веб-формах, подразумевают тег __form__ и связанные с ним теги - __input__, __select__, __label__
и т.д. Название веб-формы они получили из-за того, что тег form
объединяет информацию в группу и подсказывает браузеру, куда эти данные отправить (атрибут action) и каким именно способом осуществить отправку (атрибут __method__).

1. адрес отправки формы (значение свойства action тега form)
2. метод отправки формы(значение свойства method тега form)
3. элементы ввода (input, textarea, select и т.п.)
4. кнопка отправки формы (button или input с атрибутом type="submit")

<h3>Методы передачи данных get и post</h3>

Браузер имеет несколько методов для отправки запроса - этот механизм встроен в теги __\<a>__ и __\<img>__ .
Браузер находит атрибут __href__ или **src**, получает из них строку с **url**,
и обращается по указанному в **url** протоколу к ресурсу локальному или удаленному (через обращение к серверу).

Похожий, но более мощный механизм встроен в теге **form**. Этот механизм не использует готовую строку, подобно строке
**href** или **src**, а формирует такую строку сам.

Вот порядок, в котором происходит создание строки запроса по протоколу **HTTP**:
* С помощью атрибута **action** задается адрес, по которому будет передан запрос.

* Далее с помощью атрибута **method** выбирается один из 2-х вариантов HTTP методов - метод **GET** или **POST**.
  Метод GET в браузерах установлен по умолчанию, и его специально задавать нет необходимости.
  Метод POST необходимо задавать, если передаваемые данные содержат конфиденциальную информацию - логин и пароль, например.

* Затем, после специального знака разделителя, в строке следуют пары "**ключ: значение**" .

* Атрибут отправки **submit** запустит проверку заполнения форм и, в случае успеха, закончит формирование строки и передаст ее браузеру.

Если использовать метод **GET**, то вся подготовленная строка будет видна в браузере. Если используется метод **POST**,
то видна будет только часть строки - т.н. заголовок. Собственно метод GET и есть отправка заголовка запроса,
без подключения тела сообщения, которое осуществляется в методе **POST**.

    При верстке макета в качестве адреса используют # , т.к. хэш адресует запрос на эту же 
    страницу. Т.е. # используется временно, до работ, связанных с подключением сайта с бэкендом 
    или до наполнения его контентом

Рассмотрим пример

    <form action="#" method="get">
        <input type="text" name="name" placeholder="value"> <input type="submit" value="submit">
    </form>

<h3> input </h3>

Больше информации [здесь](https://css.in.ua/html/tag/input);

<h3>Select </h3>

Для выбора одного из нескольких вариантов помимо __checkbox__ используется конструкция __select-option__.
В теге select задается значение name и другие свойства. Каждый из вариантов для выбора задается в теге **option**.

<h3>Textarea</h3>

Для ввода текстовых данных, в которых несколько строчек используется тег textarea

<h3>Placeholder, значение по умолчанию</h3>

В некоторых случаях необходимо указать значение по умолчанию. Для этого в тегах **input** необходимо указать значение
свойства **value**, для тега **textarea** - поставить значение по умолчанию между тегами, для конструкции **select-option**
свойство **selected** в соответствующем элементе **option**.

Удобным инструментом является возможность написать подсказку о том, какие данные необходимо вносить в форму.
Такую подсказку можно реализовать с помощью свойства placeholder. Данное свойство можно указать практически в любом
элементе формы, где есть текстовый ввод.

Отличием между **placeholder** и **value** c **selected** в том, что при появлении курсора (событие фокус может быть
осуществлено мышью или клавиатурой - кнопкой **tab**) текст исчезает, а текст **value** придется удалить.
Т.е. **placeholder** не является значением input


<h2> Разные изображения для разных устройств</h2>

62% веса веба, это изображения. Большое изображение может быть идеальным на большом экране компьютера, но бесполезно 
на маленьком устройстве. Зачем загружать большое изображение, когда вы все равно должны его масштабировать? Чтобы 
уменьшить нагрузку, мы можем использовать тег **picture**.

<p align="center">
<img src="images/lesson_3/picture.png" alt="picture" width="500px">
</p>

Атрибуты **srcset**, **sizes** и тег **source** позволяют нам выделять несколько альтернативных источников и 
раздавать каждому устройству то изображение, которое лучше всего ему подходит.

* **srcset** - определяет набор изображений, которые мы разрешаем браузеру выбирать, и размер каждого изображения. 
В него, через запятую, мы записываем пары значений - url картинки и ее ширину в пикселях (для srcset это w). 
Зачем говорить браузеру какая у картинки ширина? Это браузер, разве он не знает размеры картинки? Знает! 
Но только после того, как загрузит все изображения. Если же браузер знает информацию о размере картинок с 
самого начала, будет загружена только та картинка, которая сейчас нужна.

* **sizes** - определяет набор условий среды (например, ширины экрана) и указывает, какой размер изображения 
лучше всего выбрать, когда выполняются определенные условия мультимедиа.

* **source** - тег, используется в picture, имеет 2 атрибута, media и srcset, которые в паре определяют медиаправило
и изображение, которое будет отображено при его выполнении.

Прежде чем мы посмотрим примеры, вот несколько вещей, которые нужно иметь в виду:

* **picture** требует img как своего последнего ребенка. Без img ничего не отображается. Это повышает доступность, 
поскольку есть только одно место для альтернативного текста, и оно отлично подходит для резервного содержимого в 
старых браузерах, которые не поддерживают picture.

* Думайте об атрибутах **sizes** и **тега**, как о переопределяющих атрибут src тега **img**. 
Старые браузеры просто будут использовать **img src**.

* Список srcset и sizes - это подсказка для браузеров, а не указание. Например, 
устройство с отношением пикселей 1,5 может свободно использовать изображение 1x или 2x, в зависимости от того, 
что он знает о своих возможностях, сети и т. д.

* Выражение \<img sizes="(max-width: 30rem) 100vw ..."> говорит: если этот медиа-запрос истинен, показать 
изображение с шириной 100vw. Первый подходящий медиа-запрос "побеждает", поэтому порядок источников имеет значение.

[Очень хорошая статья на эту тему](https://dev.opera.com/articles/responsive-images/)

# Что такое JS (JavaScript)

JavaScript - один из самых популярных языков программирования в мире, который широко используется в web-браузерах для описания поведения HTML-страниц в ответ на действия пользователя при взаимодействии с ними.

Здесь и далее JavaScript рассматривается в среде браузера.

Изначально язык создавался только для работы в браузере, но уже сегодня скрипты могут исполняться на любом устройстве, которое имеет специальную программу обработки кода JavaScript, в сообществе ее просто называют "движком".

Например, платформа Node js позволяет исполнять код на сервере.

Условно язык можно разделить на три компонента:

- ядро (ECMAScript);
- модель браузера
- модель документа

Последние два компонента существуют только в среде браузера.

- ECMAScript представляет собой язык без средств ввода/вывода данных и содержит описание типов данных и зарезервированных языком слов, операторов и регулярных выражений. Ядро может быть легко встроено, что позволяет без ограничений расширять его возможности и создавать производные скриптовые языки: JavaScript, CoffeeScript, TypeScript или Dart.

- Модель документа (DOM - Document Object Model) - это API для HTML-страниц и XML-документов, позволяющее производить над ними различные манипуляции, например, добавление/изменение/удаление узлов.

В сравнении с другими языками программирования JavaScript имеет следующие особенности:

- автоматическое управление памятью;
- отсутствие строгой типизации данных;
- отсутствие доступа к функциям операционной системы;
- полная интеграция с HTML-страницами и CSS;
- обработка действий пользователя и событий браузера.


# Начало работы

Единственный способ интегрировать код JavaScript - использовать тег <script>, который позволяет подключать скрипты двумя способами:

- прямой вставкой кода как в примере выше (внутренние скрипты);
- через файл (внешние скрипты).

# Внутренние скрипты

Код пишется между тегами <script></script> в HTML документе

  ```
  <!doctype html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <title>JavaScript</title>
      </head>
      
      <body>
        <h1>Hello</h1>
        <script>
          function showMessage(){
            document.getElementById("message").style.display = 'block';
          }
        </script>
      </body>
    </html>
  
  ```

# Внешние скрипты

Подключаются отдельным файлом

  ```
  <script src="scripts/index.js"></script>
  
  ```

-src - путь к файлу

Старайтесь всегда писать скрипты в отдельных файлах, чтобы поддерживать вашу кодовую базу в порядке и избегать разрастания index.html.

# Загрузка скриптов

Рассмотрим подробно процесс подключения файлов JavaScript к HTML-странице.

  ```
  Здесь важно понимать, что построение документа осуществляется считыванием кода по порядку сверху вниз
  
  ```

  ```
  Когда браузер доходит до тега <script>, он начинает загружать исполняемый код и на время загрузки скрипта блокирует дальнейшее построение страницы.
  
  ```

При быстром интернете задержка будет не видна, но при медленном сетевом соединении она вряд ли останется незамеченной для пользователя.

  ```
  <p>Before script execution</p>
    
    <script>alert('Script execution');</script>
    
  <p>After script execution</p>
  
  ```

Также отображение страницы может быть приостановлено выполнением самого кода.

В приведенном примере сначала отобразится текст Before Script Execution, а после выполнения кода - After Script Execution.

Чтобы избежать такого поведения, обычно скрипты подключают в самом конце перед закрывающим тегом.

```
  <script src="scripts/index.js"></script>
  </body>
  
```

Но и это не решает всех проблем. Если у вас более одного подключаемого файла JavaScript, то каждый последующий файл не будет загружен до тех пор, пока не загрузится предыдущий.  
**Здесь уже необходимо использовать атрибуты async и defer.**

# Async

Атрибут async выполняет скрипт в асинхронном режиме. Это означает, что загрузка кода JavaScript осуществляется в фоновом процессе и процесс построения HTML-документа не приостанавливается, браузер работает в штатном режиме.

Сам код будет выполнен после полной загрузки файла.

  ```
  <script src="scripts/script1.js" async></script>
  <script src="scripts/script2.js" async></script>
  
  ```

**Атрибут JavaScript async не сохраняет порядок выполнения файлов, описанный при их подключении. Первым выполнится тот скрипт, который первым будет загружен**

# Defer

Подобно атрибуту async defer также загружает и выполняет JavaScript-код асинхронно. Но у defer есть две особенности:

- скрипты выполняются в порядке их подключения, т.е. даже если следующие за первым файлы загрузятся раньше, они будут ждать загрузки и выполнения первого скрипта;

- загруженный код выполняется только после полной загрузки страницы.

Атрибут defer используют тогда, когда выполнение следующего скрипта зависимо от предыдущего.

  ```
  JavaScript async и defer применяются только для внешних скриптов и позволяют размещать теги  <script> на странице в любом месте. Поэтому оптимальным вариантом размещения будет тег <head>
  
  ```

# Типы данных

JavaScript относится к слабо типизированным языкам программирования, что подразумевает отсутствие необходимости указывать тип данных при объявлении переменной. В процессе выполнения скрипта тип данных будет определен автоматически.

Типы данных JavaScript:

Number (число);
String (строка);
Boolean (логический тип);
Null;
Undefined (тип неопределен)
Object (объект).
Symbol
BigInt

Все типы данных в JS кроме объектов являются примитивными. Примитивными считаются те типы данных, значения которых не могут быть изменены, а только перезаписаны совершенно новым значением.

# Number

Тип Number соответствует числам.

  ```
  5 
  3.14
  -1
  
  ```

В JavaScript к числовому типу данных также относятся значения NaN (Not A Number или "не число") и Infinity (бесконечность). Значение NaN получается в результате арифметической операции числа и любого другого типа данных, когда механизм неявного приведения типов оказался бессилен.

  ```
  'String' / 10; // тип Number, значение NaN
  
  ```

Infinity является результатом деления любого числа на 0

  ```
  1 / 0; //тип Number, значение Infinity
  
  ```

# String

Строками в JavaScript представлены текстовые данные. Строка представляет собой последовательность символов и создается с помощью одинарных, двойных или обратных кавычек.

  ```
  'Hello'
  "How are you?"
  
  ```

# Boolean

Тип данных Boolean, или логический тип, представлен двумя значениями: true (истина) и false (ложь).


  ```
  
  true; //Boolean
  false; //Boolean
  5 > 10; //Boolean (false)
  
  ```

# Null

Единственным значением типа данных Null в JS является null, означающим "ничего" или пустое значение. Обычно используется для намеренного "сброса" значения переменной, обычно применительно к объектам.

  ```
  let account = {
    login: 'login',
    password: 'pwd'  
  };
  console.log(account.login);
  account = null; //значение null тип Null
  console.log(account.login); //Uncaught TypeError: Cannot read property 'login' of null
  
  ```

# Undefined


Тип Undefined имеет единственное значение undefined, которое говорит о том, что переменной еще не было присвоено значение. 
Только что объявленные переменные, которым изначально не было задано никакого значения, равны undefined.

  ```
  let a; //значение undefined тип Undefined
  
  ```

# Object

Тип Object представлен объектами и считается сложным типом данных JavaScript. Это значит, что при создании объекта в памяти для него выделяется область, а в самой переменной сохраняется ссылка на эту область памяти. При изменении значения объекта его место в памяти не меняется.

Объект представляет собой набор свойств и может рассматриваться как контейнер для множества значений. В ходе выполнения скрипта объект может расширяться новыми свойствами или же из него могут быть удалены уже существующие.

  ```
  let account = {
    login: 'login',
    password: 'pwd'  
  };
  account.lastLogin = '01.02.2020';
  
  ```

Здесь в примере после объявления и инициализации переменной account значение объекта расширяется дополнительным свойством lastLogin, но значение самой переменной account остается неизменным, поскольку она хранит ссылку на значение объекта.

# Оператор typeof


JavaScript оператор typeof используется для определения типа данных. Единственным аргументом typeof принимает значение, тип которого необходимо определить, и возвращает наименование определенного типа в строковом виде.

  ```
  console.log(typeof 9); // number
  console.log(typeof NaN); // number
  console.log(typeof 'String'); // string
  console.log(typeof true); // boolean
  console.log(typeof {name: 'Sally'}); // number
  console.log(typeof null); // object
  console.log(typeof undefined); // undefine
  
  ```

# Переменные

Переменные в JavaScript используются для записи и хранения данных. Для определения переменных используются ключевые слова var, let и const.

  ```
  var name = 'Vasya';
  let programinLanguage = 'javascript';
  const age = 20;
  
  ```

# Различия var, let и const

let

Создание в JavaScript переменной с использованием директивы let - современный метод объявления переменной.

  ```
  Область видимости такой переменной ограничивается блоком кода, в котором она создается, и всеми его дочерними блоками. Переменная не может использоваться за пределами этого блока.
  
  ```

Блоком считается область, ограниченная фигурными скобками, например, тело операторов условий, циклов, функций, классов. Глобальная область видимости HTML-документа также является блоком.

  ```
  let globalCount = 0;
  {
    let localCount = 1;
  }
  console.log(globalCount); // 0
  console.log(localCount); //Uncaught ReferenceError: localCount is not defined
  
  ```

# var

Объявление переменной с помощью var сегодня считается устаревшим способом

Директива JS var позволяет определить переменную уже после ее использования, т.к. объявление такие переменных выполняется еще до выполнения самого кода. Такое поведение называется всплытием.

  ```
  count = 5;
  var count;
  console.log(count);
  
  ```

При использовании JS let выполнение такого кода привело бы к ошибке. Областью видимости переменной, объявленной с помощью JS var, является ее контекст выполнения.

  ```
  Всплытие актуально только для переменных, объявленных через var.
  
  ```

  ```
  Область видимости переменной, объявленной через var, это её текущий контекст выполнения. Который может ограничиваться функцией или быть глобальным, для переменных, объявленных за пределами функции.
  
  ```

# const

Директива JS const используется для объявления переменных, значение которых неизменно. Такие переменные называются константами. Присваивание нового значения или переопределение константы закончится ошибкой.

  ```
  const a = 1;
  
  a = 2; // Error
  
  ```

# Объявление переменных JavaScript


Каждая переменная должна иметь уникальное название (имя), которое называется идентификатором

Создание переменной называется объявлением переменной, а сохранение в нее значения - операцией присваивания или инициализацией.

В JavaScript все переменные хранятся в оперативной памяти.

При наличии двух и более переменных с одинаковым названием будет сгенерировано исключение

  ```
  let userName = 'Alex';
  let userName = 'John'; //ошибка, переменная с таким именем уже существует
  
  ```

![img](https://gblobscdn.gitbook.com/assets%2F-MKkb4Fd0vdhlC7Zqe4Y%2F-MMGjL1uwBDB59NJVSb_%2F-MMGootaKEw4M7Vu7c5C%2Fimage.png?alt=media&token=2347211d-4f65-46d0-ac46-4d4f3294fba9)

Все ошибки, возникающие в коде JavaScript, отображаются в консоли браузера. Из выводимой информации можно узнать, что именно произошло и в каком месте.

Значение JavaScript переменной может изменяться сколько угодно раз. При этом все предыдущие значения удаляются из памяти.

  ```
  let userName = 'va';
  userName = 2;
  userName = false;
  
  ```

# Именование переменных JavaScript

- в названии можно использовать только латинские символы, цифры и символы - и $
- имя не должно начинаться с цифры;
- названия переменных чувствительны к регистру;
- названиями не могут быть ключевые слова JavaScript

Старайтесь называть переменные так, чтобы ее назначение было понятно из ее имени. Не используйте аббревиатуры, сокращения и общие понятия. Если название состоит из нескольких слов, можно использовать следующие варианты записи:

  ```
  userName, стиль camelCase;
  user_name, стиль underscore.
  
  ```

# Выражения и операторы

В JavaScript выделяют следующие типы операторов:

- Присваивания (=, +=, -=, *=, /=)
- Арифметические (+, -, *, /)
- Сравнения (>, <, ==)
- Логические (||, &&)
- Условные

  ```
  let amount1 = -1;
  let amount2 = 1 - amount1;
                     
  ```

Здесь в первом случае оператор вычитания является унарным, а во втором - бинарным.

# Оператор присваивания

Оператор присваивания = используется для записи значения в переменную.

  ```
    var a; // тип Undefined
    a = 'JavaScript'; // тип String
  ```

++ (инкремент, или увеличение на единицу), может применяться в качестве префикса или постфикса. Использование оператора в качестве префикса сперва увеличит значение переменной, а потом использует его, в качестве постфикса - сначала использует значение, а затем увеличит его

  ```
   let inc = 1;
  //инкремент постфикс
  let a = inc++; //в a сохранится 1
  //инкремент префикс
  let a = ++inc; //в a сохранится 2
                     
  ```

-- (декремент, или уменьшение на единицу), также может применяться как префикс или как постфикс

  ```
    let decr = 1;
    //декремент постфикс
    let a = decr--; //в a сохранится 1
    //декремент префикс
    let a = --decr; //в a сохранится 0
                     
  ```

% (остаток от деления)

  ```
    let left = 5 % 2; //здесь в left запишется остаток от деления 5 на 2, т.е. 1
                     
  ```


#Операторы сравнения

Операторы сравнения используются для сравнения операндов и возвращают результат типа Boolean (логическое значение, true или false).

В JavaScript операторами сравнения являются:

== (равно), возвращает true, если значения равны между собой

    ```
      3 == 3; //true
      1 == 3; //false
    ```

!= (не равно), возвращает true, если значения не равны между собой

     ```
      3 != 3; //false
      1 != 3; //true
     ```

=== (строгое равно), возвращает true, если значения равны между собой и имеют одинаковый тип данных

  ```
    3 === 3; //true
    3 === '3'; //false, здесь первый операнд число, а второй - строка
                     
  ```

!== (не строгое равно), возвращает true, если значения не равны между собой и/или имеют разный тип данных

  ```
    3 !== 3; //false
    3 !== '3'; //true, здесь первый операнд число, а второй - строка
  ```

>, < (больше и меньше)

  ```
    3 < 5; //true
    4 > 7; //false
              
  ```

>=, <= (больше или равно и меньше или равно)

  ```
    5 <= 5; //true
    6 >= 9; //false
  ```



#Логические операторы


Логические операторы JavaScript используются применительно к булевым значениям и выражениям, возвращаемым результатом также является булевое значение.

К логическим операторам относятся

- && (и), возвращает первый операнд, если его значение равно (или может быть преобразовано) false, в противном случае возвращается значение второго операнда. Проще говоря, && вернет true, если оба операнда равны true, или вернет false, если значение одного из операндов равно false

  ```
   5 == 5 && 1 == 3; //false
   5 == 5 && 1 == 1; //true
  
  ```

- || (или), возвращает значение первого операнда, если он равен true, в противном случае возвращается второй операнд. Проще говоря, || вернет первый попавшийся операнд, значение которого равно (или может быть преобразовано) true, иначе будет возвращено false

  ```
  2 == 3 || 3 == 3; //true
  5 != 5 || 1 != 1; //false
  5 != 5 || 1 != 7; //true
  ```

- ! (не), возвращает обратное булевое значение операнда

  ```
  !false; //вернет true 
  !true; //вернет false
  
  ```

- Операторы && и || могут также использоваться с выражениями.


  ```
  let a = 1, b = 2, c;
  c = b > a && a + b; //в c запишется 3
  
  ```

Поскольку здесь значение первого JavaScript выражения b > a равно true, в переменную c сохраняется значение второго выражения a + b. Если бы b > a вернуло false, то и в c было бы false

  ```
  let a = false, b = 10;
  let value = a || b; //value равно 10
  
  ```

#Условные операторы

Условный оператор принимает одно из двух значений (или выражений) в зависимости от истинности переданного ему условия. Условный оператор еще называют тернарным, т.к. это единственный оператор JavaScript, который работает с тремя операндами.

Структура тернарного оператора


  ```
  условие ? значение, если истина : значение, если ложно
  
  ```

Пример использования тернарного JavaScript оператора


  ```
  let score = 110;
  let win = score > 100 ? 'Yes' : 'No'; //значение win - 'Yes'
  
  ```
<hr/>
<hr/>

# Преобразование типов

* Строковое преобразование
* Численное преобразование
* Логическое преобразование



# Строковое преобразование
Для того чтобы явно преобразовать значение в строку, можно воспользоваться функцией **String()**.

Неявное преобразование вызывает использование обычного оператора сложения, +, с двумя операндами, если один из них является строкой:

```
String(123) // явное преобразование
123 + ''    // неявное преобразование
```

Все примитивные типы преобразуются в строки вполне естественным и ожидаемым образом:

```
String(123)    // '123'
String(-12.3)  // '-12.3'
String(null)   // 'null'
String(undefined)  // 'undefined'
String(true)   // 'true'
String(false)  // 'false'
```

В случае с типом **Symbol** дело несколько усложняется, так как значения этого типа можно преобразовать к строковому типу только явно.

```
String(Symbol('my symbol'))   // 'Symbol(my symbol)'
'' + Symbol('my symbol')      // ошибка TypeError
```

Что будет?

```
let a = 1 + ''; // a === ?
let b = 2 + 'hello'; // b === ?
let c = typeof(String(12) + 1); // c === ?
let d = 12 + '1'; // d === ? 
```


# Преобразование к типу Boolean

Для того чтобы явно преобразовать значение к логическому типу, используют функцию **Boolean()**.

Неявное преобразование происходит в логическом контексте, или вызывается логическими операторами **(|| && !)**.

```
Boolean(2)          // явное преобразование
if (2) { ... }      // неявное преобразование в логическом контексте
!!2                 // неявное преобразование логическим оператором
2 || 'hello'        // неявное преобразование логическим оператором
```

Обратите внимание на то, что операторы, вроде || и && выполняют преобразование значений к логическому типу для внутренних целей, а возвращают значения исходных операндов, даже если они не являются логическими.

```
// это выражение возвращает число 123, а не true
// 'hello' и 123 неявно преобразуются к логическому типу при работе оператора && для вычисления значения выражения
let x = 'hello' && 123;   // x === 123
```

Так как при приведении значения к логическому типу возможны лишь два результата — **true** или **false**, легче всего освоить этот вид преобразований, запомнив те выражения, которые выдают **false**:

```
Boolean('')           // false
Boolean(0)            // false     
Boolean(-0)           // false
Boolean(NaN)          // false
Boolean(null)         // false
Boolean(undefined)    // false
Boolean(false)        // false
```

# Преобразование к типу Number

Явное преобразование к числовому типу выполняется с помощью функции **Number()** — то есть по тому же принципу, который используется для типов **Boolean** и **String**.

Неявное приведение значения к типу Number выполняют следующие операторы:

- Операторы сравнения **(>, <, <=, >=)**.
- Побитовые операторы **(|, &, ^, ~)**.
- Арифметические операторы **(-, +, *, /, %)**. Обратите внимание на то, что оператор + с двумя операндами не вызывает неявное преобразование к числовому типу, если хотя бы один оператор является строкой.
- Унарный оператор **+**.
- Оператор нестрогого равенства **==** **(а также !=)**. Обратите внимание на то, что оператор == не производит неявного преобразования в число, если оба операнда являются строками.

```
Number('123')   // явное преобразование
+'123'          // неявное преобразование
123 != '456'    // неявное преобразование
4 > '5'         // неявное преобразование
5/null          // неявное преобразование
true | 0        // неявное преобразование
```

Вот как в числа преобразуются примитивные значения:

```
Number(null)         // 0
Number(undefined)    // NaN
Number(true)         // 1
Number(false)        // 0
Number(" 12 ")       // 12
Number("-12.34")     // -12.34
Number("\n")         // 0
Number(" 12s ")      // NaN
Number(123)          // 123
```

Значения типа Symbol не могут быть преобразованы в число ни явно, ни неявно

```
Number(Symbol('my symbol'))    // Ошибка TypeError
+Symbol('123')                 // Ошибка TypeError
```

Вот правила, которые стоит запомнить:

```
null == 0               // false, null не преобразуется в 0
null == null            // true
null === null           // true
undefined == undefined  // true
undefined === undefined  // true
null == undefined       // true
null === undefined      // false
```

# Преобразование типов для объектов

Самое простое — это преобразование в логическое значение: любое значение, не являющееся примитивом, всегда true

```
const person = {
 name: 'Vlad'
};
Boolean(person); // true
const obj = {};
Boolean(obj); // true
```

Но что будет, если я приведу object к строке?

```
let a = {};
console.log(a + ''); // [object Object]
```

А если к числу?

```
const b = {};
console.log(b + 1); // [object Object]1
```

Для этого есть стандартные методы js - **toString()** и **valueOf()** :


```
let person = {
 name: 'Vlad',
 toString: function () {
   return 'Hello World!'
 },
 valueOf: function () {
   return 1
 }
};
String(person); // 'Hello World!'
person + 1; // 2
person + ''; // '1'
```

!!! Обратите внимание на то, что person + '' возвращает ‘1’ в виде строки. Оператор **+** вызывает стандартный режим преобразования. Как уже было сказано, Object рассматривает приведение к числу как преобразование по умолчанию, поэтому использует сначала метод valueOf() а не toString().


# Примеры

```
true + false             // 1
12 / "6"                 // 2
"number" + 15 + 3        // 'number153'
15 + 3 + "number"        // '18number'
[1] > null               // true
"foo" + + "bar"          // 'fooNaN'
'true' == true           // false
false == 'false'         // false
null == ''               // false
!!"false" == !!"true"    // true
['x'] == 'x'             // true 
[] + null + 1            // 'null1'
[1,2,3] == [1,2,3]       // false
```

![help](https://a.d-cd.net/SYAAAgKXiOA-960.jpg)




# Тип BigInt

BigInt – это специальный числовой тип, который предоставляет возможность работать с целыми числами произвольной длины.

Чтобы создать значение типа BigInt, необходимо добавить n в конец числового литерала или вызвать функцию BigInt()

```
const bigint = 1234567890123456789012345678901234567890n;
const sameBigint = BigInt("1234567890123456789012345678901234567890");
const bigintFromNumber = BigInt(10); // то же самое, что и 10n
```


BigInt можно использовать как обычные числа, к примеру:

```
console.log(1n + 2n); // 3
console.log(5n / 2n); // 2
```

Но в математических операциях мы не можем смешивать bigint и обычные числа:

```
alert(1n + 2); // Error: Cannot mix BigInt and other types
```


# Функции (function)

В JavaScript функция является особым типом объекта, который позволяет закладывать и применять определенную логику для обработки данных.

**Синтаксис**

```
function наименование_функции(аргумент_1, аргумент_2, ..., аргумент_N){
  тело_функции
}
```

Вызов функции JavaScript осуществляется по ее имени, за которым следуют круглые скобки с аргументами (если они имеются)

Именно круглые скобки говорят, что функцию необходимо выполнить.

```
function sayHello() {
  console.log('Hello World');
}
sayHello(); // в консоли будет Hello World
```

- Давайте напишем функцию, которая будет выводить сумму чисел 1 и 5 в консоль


Рассмотрим пример с аргументами:

```
function sayHello(name) {
 console.log('Hello, ' + name);
};
sayHello('Vlad'); // в консоли будет Hello, Vlad
```

- name - аргумент функции sayHello

Аргументы передаем в вызов функции. Можно передавать любое кол-во аргументов.

```
function sayHello(name, lastName, age) {
 console.log('Hello, ' + name + ' ' + lastName);
 console.log('Your age - ' + age)
};
sayHello('Oleg', 'Popov', 10);
```

В приведенном примере объявляется функция sayHello(), которая принимает три аргумента - name, lastName, age.

Давайте напишем функция, которая будет выводить в консоль сумму двух аргументов.

```
function calc(a, b) {
 ...
}
```


На объявление функции распространяется действие механизма всплытия.

Это значит, что в скрипте функция может быть вызвана до ее физического объявления.

```
printMessage('JavaScript Functions');
function printMessage(message){
  console.log(message);
}
```

Функции JavaScript также могут быть анонимными.

Анонимной называется функция без имени.

Такие функции используются в качестве callback-ов при обработке событий или присваиваются переменным, которые в дальнейшем передается другим функциями как параметры.

```
let sayHello = function(name) {
    console.log('Name is ' + name)
}
sayHello('Vova');
```

Функция передана в качестве аргумента:

```
let action = function() {
    console.log('action')
}
let doSomething = function(func) {
    func();
}
doSomething(action);
```

Значения для аргументов можно устанавливать по умолчанию:

```
function sayHello(name = 'Vlad') {
 console.log('Hello, ' + name);
};
sayHello(); // в консоли будет Hello, Vlad
```

Если передать аргумент, то он перетрет значение по умолчанию.

Бывают случаи, когда необходимо, чтобы функция принимала заранее неизвестное количество аргументов.

В JavaScript это возможно сделать используя так называемые REST-аргументы.

```
function sum(...numbers) {
    console.log(numbers);
};
sum(1, 2, 3); // [1,2,3]
sum(1, 2, 3, 4, 5); // [1,2,3,4,5]
```

Обратите внимание на синтаксис описания REST-аргументов при объявлении функции: они описываются как один аргумент, но с многоточием в начале.

Здесь многоточие является оператором расширения.

В теле функции значением аргумента является массив со всеми переданными значениями.

Допускается одновременное использование обычных и REST-параметров.

```
function sum(a, b, ...numbers){
    console.log(a, b, numbers);
};
sum(1, 2, 3); // 1, 2, [3]
sum(1, 2, 3, 4, 5); // 1, 2, [3,4,5]
```

Также внутри каждой функции доступна для использования переменная arguments, которая содержит массив всех переданных функции параметров.

```
function someFunc1(a, b, c){
  return arguments;
}
function someFunc2(...params){
  return arguments;
}
someFunc1('Hello', 1, true); // ['Hello', 1, true]
someFunc2(1, 2, 3); // [1, 2, 3]
```

# Ключевое слово return

Ключевое слово return является оператором JavaScript, который возвращает переданное ему значение и завершает выполнение функции.

```
function getValue(a){
  return a;
}
getValue(3); // 3
```

Если не передать значение, то функция вернет undefined.

```
function someFunc(){
  return;
}
someFunc(); // undefined
```

Весь код, следующий после использования оператора return, никогда не будет выполнен.

```
function getValue(a){
  if(a > 0) {
    return a;
  } else { 
    return 0;
  }
  
  console.log('test'); // никогда не выполнится
}
getValue(3); // 3
getValue(-2); // 0
```

Зачем нужен return

```
function getValue() {
 return 1;
}
let value = getValue();
// value === 1
```

```
funtion getValue(a, b) {
 return a + b;
}
let result = getValue(1, 2);
// result === 3
```

# Стрелочные функции

Стрелочные функции JavaScript представляют собой анонимные функции с более удобным синтаксисом.

Синтаксис стрелочной функции JavaScript.

```
(параметр_1, ..., параметр_N) => {...}
```

Пример:

```
const func = () => {
  console.log('hello');
};
func();
```

Пример с аргументами:

```
let arrowFunc = (a, b) => {
  return a + b;
};
arrowFunc(3, 7); // 10
```

Если тело функции состоит из одной строки и при этом возвращает значение, то фигурные скобки и оператор return можно опустить.

```
let arrowFunc = (a, b) => a + b;
const result = arrowFunc(2, 6);
// result === 8
```

Тоже самое что и:

```
let arrowFunc = (a, b) => {
  return a + b
};
const result = arrowFunc(2, 6);
// result === 8
```

# Массив

Массив - это упорядоченная коллекция значений. Значения в массиве называются элементами, и каждый элемент характеризуется числовой позицией в массиве, которая называется индексом (**индексы начинаются с нуля**).

Создание массивов:

```
const arr = [];
```

Массив может хранить в себе любые значения:

```
const arr = [1, 2, 3, '4'];
```

Другой способ создания массива состоит в вызове конструктора Array():

```
const arr = new Array(5, 4, 3, 2, 1, "тест");
```

# Чтение и запись элементов массива

Доступ к элементам массива осуществляется с помощью оператора [].

```
массив[индекс]
```

Слева от скобок должна присутствовать ссылка на массив.

**Внутри скобок должно находиться произвольное выражение, возвращающее неотрицательное целое значение**.

Этот синтаксис пригоден как для чтения, так и для записи значения элемента массива.

Следовательно, допустимы все приведенные далее JavaScript-инструкции:

```
// Создать массив с одним элементом
const arr = [1, 2, 3];
// Получаем первый элемент массива
console.log(arr[0]); // 1
// Записываем новый элемент в массив
arr[3] = 'test';
console.log(arr); [1, 2, 3, 'test']
//Запись нового элемента через выражение
arr[1 + 3] = 'hello';
console.log(arr); // [1, 2, 3, 'test', 'hello']
```


# Введение в методы и свойства

Методы JavaScript это действия, которые можно выполнить с объектами.

Метод JavaScript это свойство, содержащее определение функции.


Обращение к методам объекта

```
имяОбъекта.имяМетода()
```

Пример:

```
const person = {
 name: 'Vlad',
 sayHi: function() {
   console.log('Hello');
 }
}
person.sayHi(); // Hello
```

Так же можно использовать return и аргументы:

```
const person = {
 name: 'Vlad',
 saySomething: (a) => {
   console.log(a);
 },
 getName: function() {
   return 'Vlad';
 }
};
person.saySomething('Hello, how are you?');
const personName = person.getName(); // 'Vlad'
```

# Строка JavaScript может рассматриваться как массив символов.


```
let str = 'JavaScript';
/*
  str[0] - 'J'
  str[1] - 'a'
  str[2] - 'v'
  str[3] - 'a'
  str[4] - 'S'
  str[5] - 'c'
  str[6] - 'r'
  str[7] - 'i'
  str[8] - 'p'
  str[9] - 't'
*/
//можно обратиться к любому символу
console.log(str[4]); //'S'
//можно узнать длину строки
console.log(str.length); //10
```

# Использование встроенных методов строк

В JavaScript имеется широкий набор методов для работы со строками.

Рассмотрим наиболее популярные из них:

- split

Метод split разбивает строку на массив по заданному разделителю

Синтаксис

```
string.split(delim)
```

Пример:

```
let names = 'Вася, Петя, Маша';
let arr = names.split(', ');
console.log(arr);  ["Вася", "Петя", "Маша"]
```

- toUpperCase() / toLowerCase() - преобразование значения в верхний/нижний регистр;

```
let greeting = 'Hello';
console.log(greeting.toUpperCase()); //HELLO
console.log(greeting.toLowerCase()); //hello
```
- indexOf() - поиск заданного значения в строке; метод возвращает индекс первого найденного значения или же -1, если совпадений нет; поиск чувствителен к регистру

```
let str = 'Welcome to WebDraftt. Learn JavaScript on WebDraftt';
console.log(str.indexOf('WebDraftt')); // 11
console.log(str.indexOf('webdraftt')); // -1
```

- slice() - возвращает часть строки по заданным начальному и конечному индексам; если передать отрицательные значения, то отсчет будет осуществляться с конца строки

```
let str = 'Hello. My name is Molly.';
console.log(str.slice(7, 9)); // My
//если второй параметр не указан, то будет возвращена часть //строки с заданного индекса и до ее конца  
console.log(str.slice(7)); // My name is Molly.
//пример с отрицательными значениями
console.log(str.slice(-6, -1)); // Molly
```

- substring() - возвращает часть строки по заданным начальному и конечному индексам, не принимает отрицательных значений

```
let str = 'Hello. My name is Molly.';
console.log(str.substring(7, 9)); // My
//если второй параметр не указан, то будет возвращена часть //строки с заданного индекса и до ее конца  
console.log(str.substring(7)); // My name is Molly.
```

- replace() - заменяет вхождения заданного значения (значение может быть регулярным выражением) на новое значение, указываемое вторым параметром

```
let str = 'Jack is my friend. Jack is a doctor.';
console.log(str.replace('Jack', 'Paul')); // Paul is my friend. Jack is a doctor
```

- trim() - удаление пробелов в начале и конце строки

```
let str = '  String with extra spaces ';
console.log(str.trim()); // 'String with extra spaces'
```


# Использование встроенных методов массива

- toString / join

Метод toString() возвращает массив в виде строки, в которой все его элементы перечислены через запятую.

```
let arr = [1, 'John', true];
alert(arr.toString()); // "1,John,true"
```

Метод join() идентичен методу toString() и отличается от него лишь тем, что с его помощью можно задать разделитель, отличный от запятой (по умолчанию).

```
let arr = [1, 'John', true];
alert(arr.join('.')); // "1.John.true"
alert(arr.join('|')); // "1|John|true"
```

- unshift / push

В JavaScript методы unshift() и push() используются для добавления в массив новых элементов: unshift() добавляет элемент в начало, push() - в конец

```
let arr = [2, 3, 4];
arr.unshift(1);
console.log(arr); // [1,2,3,4]
arr.push(5);
console.log(arr); // [1,2,3,4,5]
```

- shift / pop

Методы shift() и pop() предназначены для удаления элементов из массива: shift() удаляет первый элемент, pop() - последний. Оба метода возвращают значение удаляемого элемента.

```
let arr = [1, 2, 3];
let firstElement = arr.shift(); // 1
console.log(arr); // [2,3]
let lastElement = arr.pop(); // 3
console.log(arr); // [2]
```

- concat / slice

Объединение массивов в JavaScript осуществляется с использованием метода concat(), а извлечение части массива в новый отдельный - с использованием метода slice()

Метод concat() принимает массив и возвращает новый объединенный массив, который является результатом объединения исходного массива (применительного к которому вызывается concat()) и массива, переданного в качестве параметра.

При этом значения исходных массивов не изменяются.

```
let arr1 = [1, 2];
let arr2 = [3, 4, 5];
let arr3 = arr1.concat(arr2);
console.log(arr1); // [1,2]
console.log(arr2); // [3,4,5]
console.log(arr3); // [1,2,3,4,5]
```

Метод slice() возвращает часть исходного массива как новый массив, не изменяя при этом исходный массив, и принимает два параметра:

- индекс элемента, который будет первым в результирующем массиве;
- индекс элемента, до которого все предыдущие элементы будут частью результирующего массива, но сам он в результирующий массив включен не будет (необязательный параметр).

```
let arr1 = [1, 2, 3, 4, 5];
let part1_of_arr1 = arr1.slice(3); // [4,5]
let part2_of_arr1 = arr1.slice(2, 4); // [3,4]
console.log(arr1); // [1, 2, 3, 4, 5]
```

- splice

Метод splice() позволяет изменять содержимое массива, добавляя в него новые элементы или же удаляя существующие. JavaScript splice() может принимать следующие параметры:

- индекс, относительно которого будет происходить изменение массива;
- количество элементов, которое необходимо удалить;
- элементы, которые необходимо добавить в массив (в виде REST-аргумента).

Возвращаемым значением splice() является массив удаленных элементов.


```
let arr = ['a', 'b', 'c', 'd', 'e'];
let deletedItems = arr.splice(1, 2); // ['b', 'c']
console.log(arr); // ['a', 'd', 'e']
```

- forEach / map

Методы для перебора элементов в массиве.
Разница между ними в том, то метод map возвращает новый массив, а forEach - нет.

```
const arr = [1, 2, 3];
arr.forEach(function(item, i, arr) {
 console.log(item); // 1, 2, 3
 console.log(i); // 0, 1, 2
 console.log(arr); // [1, 2, 3]
});
const newArray = arr.map(function(item, i, arr) {
 console.log(item); // 1, 2, 3
 console.log(i); // 0, 1, 2
 console.log(arr); // [1, 2, 3]
 return item;
});
// newArray === [1, 2, 3];
```

- filter / sort

Фильтрация и сортировка массива в JavaScript осуществляется с использованием методов filter() и sort() соответственно.

Метод filter() возвращает новый массив элементов, которые удовлетворяет заданному переданной функцией условию, применяемой к каждому элементу.

Так, filter() принимает первым аргументом функцию, которая принимает в себя 3 аргумента - item (элемент массива), i (индекс элемента массива), arr (сам массив)

```
let arr = [3, 5, 12, 9, 23, 93, 17];
let filteredArr = arr.filter(el => el <= 10); // [3, 5, 9]
```


Давайте отфильтруем массив [1,2,3,4,5,6,7,8,9,10] и получим новый массив только из четных чисел.

```
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
...
```

Метод sort() сортирует элементы массива по возрастанию, причем порядок элементов меняется прямо в массиве.

```
let arr = ['b', 'c', 'a', 'e', 'd'];
arr.sort();
    
console.log(arr); // ['a', 'b', 'c', 'd', 'e']
```

Важно понимать, что сортировка осуществляется по символам и по значениям их кодов в таблице Unicode.

Например, сортировка массива чисел, в котором присутствуют двузначные числа, будет осуществляться сначала по первым символам, а потом уже по вторым.

```
let arr = [3, 5, 19, 1, 7, 23, 14, 9];
arr.sort();
console.log(arr); // [1, 14, 19, 23, 3, 5, 7, 9]
```

Для сортировки именно по числовым значениям (или любым другим) методу sort() необходимо задать функцию сравнения, которая будет определять, какой из элементов больше.

Параметрами функции сравнения передаются два элемента массива, которые необходимо сравнить в данный момент.

Сама функция вызывается для всех пар элементов массива.


```
let arr = [3, 5, 19, 1, 7, 23, 14, 9];
arr.sort((el1, el2) => {
  if(el1 == el2) {
    return 0;
  } else if(el1 > el2) {
    return 1;
  } else if(el1 < el2) {
    return -1;
  }
});
console.log(arr); // [1, 3, 5, 7, 9, 14, 19, 23]
```

- find / some / every

Методы find(), some() и every() используются для проверки соответствия элементов массива некоторому условию и имеют одинаковый набор параметров

Методы принимают в себя функцию с 3 аргументами. Первый аргумент (item) - сам элемент массива, второй аргумент (i) - индекс элемента, arr - сам массив

```
arr.find(function(item, i, arr) { 
 ...
});
arr.some(function(item, i, arr) {
 ... 
});
```

Метод find() используется для поиска в массиве элемента, удовлетворяющего заданному критерию.

Возвращаемым результатом вызова JavaScript find() является первый попавшийся элемент, который подходит под заданное условие. Если таких элементов в массиве нет - возвращается undefined.

```
let arr = [7, 6, 3, 5, 8, 2];
let result1 = arr.find(el => el % 4 == 0); // 8
    
let result2 = arr.find(el => el > 10); // undefined
```

Метод some() позволяет узнать, имеется ли в массиве хотя бы один элемент, удовлетворяющий заданному функцией условию, и возвращает true, если такой элемент есть, и false в противном случае.

```
let arr = [7, 6, 3, 5, 8, 2];
let result1 = arr.some(el => el % 4 == 0); // true
let result2 = arr.some(el => el > 10); // false
```

Метод every() возвращает true, если все элементы массив удовлетворяют заданному критерию или false в противном случае. Критерий задается функцией.

```
let arr = [7, 6, 3, 5, 8, 2];
let result1 = arr.every(el => el % 4 == 0); // false
let result2 = arr.every(el => el < 10); // true
```
